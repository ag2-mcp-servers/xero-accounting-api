# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T12:23:17+00:00



import argparse
import json
import os
from datetime import date, datetime
from typing import *
from typing import Optional, Union
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Header, Path, Query, Request

from models import (
    Account,
    Accounts,
    Actions,
    Allocations,
    Attachments,
    BankTransactions,
    BankTransfers,
    BatchPayments,
    BrandingThemes,
    CISOrgSettings,
    CISSettings,
    ContactGroups,
    ContactIDs,
    Contacts,
    CreditNotes,
    Currencies,
    Currency,
    Employees,
    Error,
    ExpenseClaims,
    HistoryRecords,
    IDs,
    ImportSummaryObject,
    InvoiceNumbers,
    InvoiceReminders,
    Invoices,
    Items,
    Journals,
    LinkedTransaction,
    LinkedTransactions,
    ManualJournals,
    OnlineInvoices,
    Organisations,
    Overpayments,
    Payment,
    PaymentDelete,
    Payments,
    PaymentService,
    PaymentServices,
    Prepayments,
    PurchaseOrders,
    Quotes,
    Receipts,
    RepeatingInvoices,
    Reports,
    ReportWithRows,
    RequestEmpty,
    Setup,
    Status20,
    Statuses,
    TaxRates,
    Timeframe,
    TrackingCategories,
    TrackingCategory,
    TrackingOption,
    TrackingOptions,
    Users,
)

app = MCPProxy(
    contact={
        'email': 'api@xero.com',
        'name': 'Xero Platform Team',
        'url': 'https://developer.xero.com',
        'x-twitter': 'XeroAPI',
    },
    termsOfService='https://developer.xero.com/xero-developer-platform-terms-conditions/',
    title='Xero Accounting API',
    version='2.9.4',
    servers=[
        {
            'description': 'The Xero Accounting API exposes accounting and related functions of the main Xero application and can be used for a variety of purposes such as creating transactions like invoices and credit notes, right through to extracting accounting data via our reports endpoint.',
            'url': 'https://api.xero.com/api.xro/2.0',
        }
    ],
)


@app.get(
    '/Accounts',
    tags=['account_management', 'account_setup_process'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_accounts(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves the full chart of accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Accounts',
    tags=['account_management', 'account_setup_process'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_account(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: Account = ...
):
    """
    Creates a new chart of accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/Accounts/{AccountID}',
    tags=['account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_account(
    account_i_d: UUID = Path(..., alias='AccountID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes a chart of accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Accounts/{AccountID}',
    tags=['account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account(
    account_i_d: UUID = Path(..., alias='AccountID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a single chart of accounts by using a unique account Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Accounts/{AccountID}',
    tags=['account_management', 'account_setup_process'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_account(
    account_i_d: UUID = Path(..., alias='AccountID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Accounts = ...,
):
    """
    Updates a chart of accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Accounts/{AccountID}/Attachments',
    tags=['account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account_attachments(
    account_i_d: UUID = Path(..., alias='AccountID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific accounts by using a unique account Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Accounts/{AccountID}/Attachments/{AttachmentID}',
    tags=['account_management', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account_attachment_by_id(
    account_i_d: UUID = Path(..., alias='AccountID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific account using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Accounts/{AccountID}/Attachments/{FileName}',
    tags=['account_management', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_account_attachment_by_file_name(
    account_i_d: UUID = Path(..., alias='AccountID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves an attachment for a specific account by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Accounts/{AccountID}/Attachments/{FileName}',
    tags=['account_management', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_account_attachment_by_file_name(
    account_i_d: UUID = Path(..., alias='AccountID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates attachment on a specific account by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Accounts/{AccountID}/Attachments/{FileName}',
    tags=['account_management', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_account_attachment_by_file_name(
    account_i_d: UUID = Path(..., alias='AccountID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates an attachment on a specific account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransactions',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transactions(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    page: Optional[int] = None,
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves any spent or received money transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/BankTransactions',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_bank_transactions(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: BankTransactions = ...,
):
    """
    Updates or creates one or more spent or received money transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BankTransactions',
    tags=[
        'bank_transaction_management',
        'transaction_history_management',
        'payment_processing',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_bank_transactions(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: BankTransactions = ...,
):
    """
    Creates one or more spent or received money transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransactions/{BankTransactionID}',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transaction(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a single spent or received money transaction by using a unique bank transaction Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/BankTransactions/{BankTransactionID}',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_bank_transaction(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: BankTransactions = ...,
):
    """
    Updates a single spent or received money transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransactions/{BankTransactionID}/Attachments',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transaction_attachments(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves any attachments from a specific bank transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transaction_attachment_by_id(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves specific attachments from a specific BankTransaction using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransactions/{BankTransactionID}/Attachments/{FileName}',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transaction_attachment_by_file_name(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific bank transaction by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/BankTransactions/{BankTransactionID}/Attachments/{FileName}',
    tags=['bank_transaction_management', 'account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_bank_transaction_attachment_by_file_name(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates a specific attachment from a specific bank transaction by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BankTransactions/{BankTransactionID}/Attachments/{FileName}',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_bank_transaction_attachment_by_file_name(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates an attachment for a specific bank transaction by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransactions/{BankTransactionID}/History',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transactions_history(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history from a specific bank transaction using a unique bank transaction Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BankTransactions/{BankTransactionID}/History',
    tags=['bank_transaction_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_bank_transaction_history_record(
    bank_transaction_i_d: UUID = Path(..., alias='BankTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific bank transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransfers',
    tags=[
        'bank_transfer_history',
        'transaction_history_management',
        'bank_transaction_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transfers(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves all bank transfers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BankTransfers',
    tags=['bank_transaction_management', 'bank_transfer_history'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_bank_transfer(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: BankTransfers = ...
):
    """
    Creates a bank transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransfers/{BankTransferID}',
    tags=[
        'bank_transfer_history',
        'bank_transaction_management',
        'transaction_history_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transfer(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves specific bank transfers by using a unique bank transfer Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransfers/{BankTransferID}/Attachments',
    tags=[
        'bank_transaction_management',
        'bank_transfer_history',
        'transaction_history_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transfer_attachments(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments from a specific bank transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}',
    tags=[
        'bank_transaction_management',
        'bank_transfer_history',
        'transaction_history_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transfer_attachment_by_id(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific bank transfer using a unique attachment ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransfers/{BankTransferID}/Attachments/{FileName}',
    tags=['bank_transaction_management', 'bank_transfer_history'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transfer_attachment_by_file_name(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment on a specific bank transfer by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/BankTransfers/{BankTransferID}/Attachments/{FileName}',
    tags=['bank_transfer_history', 'bank_transaction_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_bank_transfer_attachment_by_file_name(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BankTransfers/{BankTransferID}/Attachments/{FileName}',
    tags=['bank_transfer_history', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_bank_transfer_attachment_by_file_name(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BankTransfers/{BankTransferID}/History',
    tags=['bank_transfer_history', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_bank_transfer_history(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history from a specific bank transfer using a unique bank transfer Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BankTransfers/{BankTransferID}/History',
    tags=['bank_transfer_history', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_bank_transfer_history_record(
    bank_transfer_i_d: UUID = Path(..., alias='BankTransferID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific bank transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BatchPayments',
    tags=['batch_payment_handling', 'payment_processing', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_batch_payments(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves either one or many batch payments for invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BatchPayments',
    tags=['batch_payment_handling', 'invoice_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_batch_payment(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: BatchPayments = ...,
):
    """
    Creates one or many batch payments for invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BatchPayments/{BatchPaymentID}/History',
    tags=['batch_payment_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_batch_payment_history(
    batch_payment_i_d: UUID = Path(..., alias='BatchPaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history from a specific batch payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/BatchPayments/{BatchPaymentID}/History',
    tags=['batch_payment_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_batch_payment_history_record(
    batch_payment_i_d: UUID = Path(..., alias='BatchPaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific batch payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BrandingThemes',
    tags=['branding_theme_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_branding_themes(xero_tenant_id: str = Header(..., alias='xero-tenant-id')):
    """
    Retrieves all the branding themes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BrandingThemes/{BrandingThemeID}',
    tags=['branding_theme_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_branding_theme(
    branding_theme_i_d: UUID = Path(..., alias='BrandingThemeID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific branding theme using a unique branding theme Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/BrandingThemes/{BrandingThemeID}/PaymentServices',
    tags=['branding_theme_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_branding_theme_payment_services(
    branding_theme_i_d: UUID = Path(..., alias='BrandingThemeID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves the payment services for a specific branding theme
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/BrandingThemes/{BrandingThemeID}/PaymentServices',
    tags=['branding_theme_handling', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_branding_theme_payment_services(
    branding_theme_i_d: UUID = Path(..., alias='BrandingThemeID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: PaymentService = ...,
):
    """
    Creates a new custom payment service for a specific branding theme
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ContactGroups',
    tags=['contact_group_operations', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_groups(
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves the contact Id and name of all the contacts in a contact group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ContactGroups',
    tags=['contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_contact_group(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: ContactGroups = ...
):
    """
    Creates a contact group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ContactGroups/{ContactGroupID}',
    tags=['contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_group(
    contact_group_i_d: UUID = Path(..., alias='ContactGroupID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific contact group by using a unique contact group Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ContactGroups/{ContactGroupID}',
    tags=['contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_contact_group(
    contact_group_i_d: UUID = Path(..., alias='ContactGroupID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: ContactGroups = ...,
):
    """
    Updates a specific contact group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/ContactGroups/{ContactGroupID}/Contacts',
    tags=['contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_contact_group_contacts(
    contact_group_i_d: UUID = Path(..., alias='ContactGroupID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes all contacts from a specific contact group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ContactGroups/{ContactGroupID}/Contacts',
    tags=['contact_group_operations', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_contact_group_contacts(
    contact_group_i_d: UUID = Path(..., alias='ContactGroupID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Contacts = ...,
):
    """
    Creates contacts to a specific contact group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/ContactGroups/{ContactGroupID}/Contacts/{ContactID}',
    tags=['contact_group_operations', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_contact_group_contact(
    contact_group_i_d: UUID = Path(..., alias='ContactGroupID'),
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes a specific contact from a contact group using a unique contact Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts',
    tags=['contact_retrieval_operations', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contacts(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    i_ds: Optional[IDs] = Query(None, alias='IDs'),
    page: Optional[int] = None,
    include_archived: Optional[bool] = Query(None, alias='includeArchived'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves all contacts in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Contacts',
    tags=['individual_contact_management', 'contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_contacts(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Contacts = ...,
):
    """
    Updates or creates one or more contacts in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Contacts',
    tags=['contact_group_operations', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_contacts(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Contacts = ...,
):
    """
    Creates multiple contacts (bulk) in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactID}',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific contacts in a Xero organisation using a unique contact Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Contacts/{ContactID}',
    tags=['individual_contact_management', 'contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_contact(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Contacts = ...,
):
    """
    Updates a specific contact in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactID}/Attachments',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_attachments(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific contact in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactID}/Attachments/{AttachmentID}',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_attachment_by_id(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific contact using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactID}/Attachments/{FileName}',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_attachment_by_file_name(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific contact by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Contacts/{ContactID}/Attachments/{FileName}',
    tags=['individual_contact_management', 'contact_group_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_contact_attachment_by_file_name(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Contacts/{ContactID}/Attachments/{FileName}',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_contact_attachment_by_file_name(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactID}/CISSettings',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_c_i_s_settings(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves CIS settings for a specific contact in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactID}/History',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_history(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records for a specific contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Contacts/{ContactID}/History',
    tags=['individual_contact_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_contact_history(
    contact_i_d: UUID = Path(..., alias='ContactID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a new history record for a specific contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Contacts/{ContactNumber}',
    tags=['individual_contact_management', 'contact_retrieval_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_contact_by_contact_number(
    contact_number: str = Path(..., alias='ContactNumber'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific contact by contact number in a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_notes(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    page: Optional[int] = None,
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves any credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/CreditNotes',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_credit_notes(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: CreditNotes = ...,
):
    """
    Updates or creates one or more credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/CreditNotes',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_credit_notes(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: CreditNotes = ...,
):
    """
    Creates a new credit note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes/{CreditNoteID}',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_note(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific credit note using a unique credit note Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/CreditNotes/{CreditNoteID}',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_credit_note(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: CreditNotes = ...,
):
    """
    Updates a specific credit note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/CreditNotes/{CreditNoteID}/Allocations',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_credit_note_allocation(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Allocations = ...,
):
    """
    Creates allocation for a specific credit note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes/{CreditNoteID}/Attachments',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_note_attachments(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}',
    tags=['credit_note_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_note_attachment_by_id(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific credit note using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes/{CreditNoteID}/Attachments/{FileName}',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_note_attachment_by_file_name(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment on a specific credit note by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/CreditNotes/{CreditNoteID}/Attachments/{FileName}',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_credit_note_attachment_by_file_name(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates attachments on a specific credit note by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/CreditNotes/{CreditNoteID}/Attachments/{FileName}',
    tags=['credit_note_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_credit_note_attachment_by_file_name(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    file_name: str = Path(..., alias='FileName'),
    include_online: Optional[bool] = Query(False, alias='IncludeOnline'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates an attachment for a specific credit note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes/{CreditNoteID}/History',
    tags=['credit_note_operations', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_note_history(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records of a specific credit note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/CreditNotes/{CreditNoteID}/History',
    tags=['credit_note_operations', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_credit_note_history(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Retrieves history records of a specific credit note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/CreditNotes/{CreditNoteID}/pdf',
    tags=['credit_note_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_credit_note_as_pdf(
    credit_note_i_d: UUID = Path(..., alias='CreditNoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves credit notes as PDF files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Currencies',
    tags=['currency_management_operations', 'organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_currencies(
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves currencies for your Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Currencies',
    tags=['currency_management_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_currency(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: Currency = ...
):
    """
    Create a new currency for a Xero organisation
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Employees',
    tags=['employee_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_employees(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves employees used in Xero payrun
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Employees',
    tags=['employee_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_employees(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Employees = ...,
):
    """
    Creates a single new employees used in Xero payrun
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Employees',
    tags=['employee_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_employees(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Employees = ...,
):
    """
    Creates new employees used in Xero payrun
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Employees/{EmployeeID}',
    tags=['employee_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_employee(
    employee_i_d: UUID = Path(..., alias='EmployeeID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific employee used in Xero payrun using a unique employee Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ExpenseClaims',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_expense_claims(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves expense claims
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ExpenseClaims',
    tags=['expense_claim_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_expense_claims(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: ExpenseClaims = ...
):
    """
    Creates expense claims
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ExpenseClaims/{ExpenseClaimID}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_expense_claim(
    expense_claim_i_d: UUID = Path(..., alias='ExpenseClaimID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific expense claim using a unique expense claim Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ExpenseClaims/{ExpenseClaimID}',
    tags=['expense_claim_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_expense_claim(
    expense_claim_i_d: UUID = Path(..., alias='ExpenseClaimID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: ExpenseClaims = ...,
):
    """
    Updates a specific expense claims
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ExpenseClaims/{ExpenseClaimID}/History',
    tags=['expense_claim_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_expense_claim_history(
    expense_claim_i_d: UUID = Path(..., alias='ExpenseClaimID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records of a specific expense claim
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ExpenseClaims/{ExpenseClaimID}/History',
    tags=['expense_claim_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_expense_claim_history(
    expense_claim_i_d: UUID = Path(..., alias='ExpenseClaimID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific expense claim
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/InvoiceReminders/Settings',
    tags=['invoice_operations', 'organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_reminders(xero_tenant_id: str = Header(..., alias='xero-tenant-id')):
    """
    Retrieves invoice reminder settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices',
    tags=['invoice_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoices(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    i_ds: Optional[IDs] = Query(None, alias='IDs'),
    invoice_numbers: Optional[InvoiceNumbers] = Query(None, alias='InvoiceNumbers'),
    contact_i_ds: Optional[ContactIDs] = Query(None, alias='ContactIDs'),
    statuses: Optional[Statuses] = Query(None, alias='Statuses'),
    page: Optional[int] = None,
    include_archived: Optional[bool] = Query(None, alias='includeArchived'),
    created_by_my_app: Optional[bool] = Query(None, alias='createdByMyApp'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves sales invoices or purchase bills
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Invoices',
    tags=['invoice_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_invoices(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Invoices = ...,
):
    """
    Updates or creates one or more sales invoices or purchase bills
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Invoices',
    tags=['invoice_operations', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_invoices(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Invoices = ...,
):
    """
    Creates one or more sales invoices or purchase bills
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}',
    tags=['invoice_operations', 'invoice_history_records'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific sales invoice or purchase bill using a unique invoice Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Invoices/{InvoiceID}',
    tags=['invoice_operations', 'invoice_history_records'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_invoice(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Invoices = ...,
):
    """
    Updates a specific sales invoices or purchase bills
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}/Attachments',
    tags=['invoice_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_attachments(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific invoice or purchase bill
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}/Attachments/{AttachmentID}',
    tags=['invoice_attachment_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_attachment_by_id(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific invoices or purchase bills by using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}/Attachments/{FileName}',
    tags=['invoice_attachment_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_attachment_by_file_name(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves an attachment from a specific invoice or purchase bill by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Invoices/{InvoiceID}/Attachments/{FileName}',
    tags=['invoice_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_invoice_attachment_by_file_name(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates an attachment from a specific invoices or purchase bill by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Invoices/{InvoiceID}/Attachments/{FileName}',
    tags=['invoice_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_invoice_attachment_by_file_name(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    file_name: str = Path(..., alias='FileName'),
    include_online: Optional[bool] = Query(False, alias='IncludeOnline'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates an attachment for a specific invoice or purchase bill by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Invoices/{InvoiceID}/Email',
    tags=['invoice_operations', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def email_invoice(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: RequestEmpty = ...,
):
    """
    Sends a copy of a specific invoice to related contact via email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}/History',
    tags=['invoice_history_records', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_history(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records for a specific invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Invoices/{InvoiceID}/History',
    tags=['invoice_history_records', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_invoice_history(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}/OnlineInvoice',
    tags=['invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_online_invoice(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a URL to an online invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Invoices/{InvoiceID}/pdf',
    tags=[
        'invoice_operations',
        'invoice_attachment_operations',
        'invoice_history_records',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_invoice_as_pdf(
    invoice_i_d: UUID = Path(..., alias='InvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves invoices or purchase bills as PDF files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Items',
    tags=['item_record_management', 'item_history_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_items(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Items',
    tags=['item_record_management', 'item_history_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_items(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Items = ...,
):
    """
    Updates or creates one or more items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Items',
    tags=['item_record_management', 'item_history_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_items(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Items = ...,
):
    """
    Creates one or more items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/Items/{ItemID}',
    tags=['item_record_management', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_item(
    item_i_d: UUID = Path(..., alias='ItemID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes a specific item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Items/{ItemID}',
    tags=['item_record_management', 'item_history_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_item(
    item_i_d: UUID = Path(..., alias='ItemID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific item using a unique item Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Items/{ItemID}',
    tags=['item_record_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_item(
    item_i_d: UUID = Path(..., alias='ItemID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Items = ...,
):
    """
    Updates a specific item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Items/{ItemID}/History',
    tags=['item_history_tracking', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_item_history(
    item_i_d: UUID = Path(..., alias='ItemID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history for a specific item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Items/{ItemID}/History',
    tags=['item_history_tracking', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_item_history(
    item_i_d: UUID = Path(..., alias='ItemID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Journals',
    tags=['journal_entry_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_journals(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    offset: Optional[int] = None,
    payments_only: Optional[bool] = Query(None, alias='paymentsOnly'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves journals
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Journals/{JournalID}',
    tags=['journal_entry_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_journal(
    journal_i_d: UUID = Path(..., alias='JournalID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific journal using a unique journal Id.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/LinkedTransactions',
    tags=[
        'linked_transaction_handling',
        'expense_claim_handling',
        'transaction_history_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linked_transactions(
    page: Optional[int] = None,
    linked_transaction_i_d: Optional[UUID] = Query(None, alias='LinkedTransactionID'),
    source_transaction_i_d: Optional[UUID] = Query(None, alias='SourceTransactionID'),
    contact_i_d: Optional[UUID] = Query(None, alias='ContactID'),
    status: Optional[str] = Query(None, alias='Status'),
    target_transaction_i_d: Optional[UUID] = Query(None, alias='TargetTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves linked transactions (billable expenses)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/LinkedTransactions',
    tags=['linked_transaction_handling', 'expense_claim_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_linked_transaction(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: LinkedTransaction = ...,
):
    """
    Creates linked transactions (billable expenses)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/LinkedTransactions/{LinkedTransactionID}',
    tags=['linked_transaction_handling', 'expense_claim_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_linked_transaction(
    linked_transaction_i_d: UUID = Path(..., alias='LinkedTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes a specific linked transactions (billable expenses)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/LinkedTransactions/{LinkedTransactionID}',
    tags=['linked_transaction_handling', 'expense_claim_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_linked_transaction(
    linked_transaction_i_d: UUID = Path(..., alias='LinkedTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific linked transaction (billable expenses) using a unique linked transaction Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/LinkedTransactions/{LinkedTransactionID}',
    tags=['linked_transaction_handling', 'expense_claim_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_linked_transaction(
    linked_transaction_i_d: UUID = Path(..., alias='LinkedTransactionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: LinkedTransactions = ...,
):
    """
    Updates a specific linked transactions (billable expenses)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ManualJournals',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_manual_journals(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    page: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves manual journals
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ManualJournals',
    tags=['manual_journal_tracking', 'journal_entry_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_manual_journals(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: ManualJournals = ...,
):
    """
    Updates or creates a single manual journal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ManualJournals',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_manual_journals(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: ManualJournals = ...,
):
    """
    Creates one or more manual journals
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ManualJournals/{ManualJournalID}',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_manual_journal(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific manual journal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ManualJournals/{ManualJournalID}',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_manual_journal(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: ManualJournals = ...,
):
    """
    Updates a specific manual journal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ManualJournals/{ManualJournalID}/Attachments',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_manual_journal_attachments(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachment for a specific manual journal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_manual_journal_attachment_by_id(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Allows you to retrieve a specific attachment from a specific manual journal using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ManualJournals/{ManualJournalID}/Attachments/{FileName}',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_manual_journal_attachment_by_file_name(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific manual journal by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ManualJournals/{ManualJournalID}/Attachments/{FileName}',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_manual_journal_attachment_by_file_name(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates a specific attachment from a specific manual journal by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ManualJournals/{ManualJournalID}/Attachments/{FileName}',
    tags=['manual_journal_tracking', 'journal_entry_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_manual_journal_attachment_by_file_name(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates a specific attachment for a specific manual journal by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ManualJournals/{ManualJournalID}/History',
    tags=['journal_entry_management', 'manual_journal_tracking'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_manual_journals_history(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history for a specific manual journal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ManualJournals/{ManualJournalID}/History',
    tags=['manual_journal_tracking', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_manual_journal_history_record(
    manual_journal_i_d: UUID = Path(..., alias='ManualJournalID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific manual journal
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Organisation',
    tags=['organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_organisations(xero_tenant_id: str = Header(..., alias='xero-tenant-id')):
    """
    Retrieves Xero organisation details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Organisation/Actions',
    tags=['organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_organisation_actions(xero_tenant_id: str = Header(..., alias='xero-tenant-id')):
    """
    Retrieves a list of the key actions your app has permission to perform in the connected Xero organisation.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Organisation/{OrganisationID}/CISSettings',
    tags=['organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_organisation_c_i_s_settings(
    organisation_i_d: UUID = Path(..., alias='OrganisationID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves the CIS settings for the Xero organistaion.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Overpayments',
    tags=['overpayment_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_overpayments(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    page: Optional[int] = None,
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves overpayments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Overpayments/{OverpaymentID}',
    tags=['overpayment_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_overpayment(
    overpayment_i_d: UUID = Path(..., alias='OverpaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific overpayment using a unique overpayment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Overpayments/{OverpaymentID}/Allocations',
    tags=['overpayment_handling', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_overpayment_allocations(
    overpayment_i_d: UUID = Path(..., alias='OverpaymentID'),
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Allocations = ...,
):
    """
    Creates a single allocation for a specific overpayment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Overpayments/{OverpaymentID}/History',
    tags=['overpayment_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_overpayment_history(
    overpayment_i_d: UUID = Path(..., alias='OverpaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records of a specific overpayment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Overpayments/{OverpaymentID}/History',
    tags=['overpayment_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_overpayment_history(
    overpayment_i_d: UUID = Path(..., alias='OverpaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific overpayment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PaymentServices',
    tags=['branding_theme_handling', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payment_services(xero_tenant_id: str = Header(..., alias='xero-tenant-id')):
    """
    Retrieves payment services
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/PaymentServices',
    tags=['payment_processing', 'account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_payment_service(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: PaymentServices = ...,
):
    """
    Creates a payment service
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Payments',
    tags=['payment_processing', 'invoice_operations', 'credit_note_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payments(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    page: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves payments for invoices and credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Payments',
    tags=['payment_processing', 'invoice_operations', 'credit_note_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_payment(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: Payment = ...
):
    """
    Creates a single payment for invoice or credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Payments',
    tags=[
        'payment_processing',
        'batch_payment_handling',
        'invoice_operations',
        'credit_note_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_payments(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Payments = ...,
):
    """
    Creates multiple payments for invoices or credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Payments/{PaymentID}',
    tags=['payment_processing', 'credit_note_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payment(
    payment_i_d: UUID = Path(..., alias='PaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific payment for invoices and credit notes using a unique payment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Payments/{PaymentID}',
    tags=['payment_processing', 'invoice_operations', 'credit_note_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_payment(
    payment_i_d: UUID = Path(..., alias='PaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: PaymentDelete = ...,
):
    """
    Updates a specific payment for invoices and credit notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Payments/{PaymentID}/History',
    tags=['payment_processing', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_payment_history(
    payment_i_d: UUID = Path(..., alias='PaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records of a specific payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Payments/{PaymentID}/History',
    tags=['transaction_history_management', 'payment_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_payment_history(
    payment_i_d: UUID = Path(..., alias='PaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific payment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Prepayments',
    tags=['prepayment_handling', 'prepayment_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_prepayments(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    page: Optional[int] = None,
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves prepayments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Prepayments/{PrepaymentID}',
    tags=['prepayment_handling', 'prepayment_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_prepayment(
    prepayment_i_d: UUID = Path(..., alias='PrepaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Allows you to retrieve a specified prepayments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Prepayments/{PrepaymentID}/Allocations',
    tags=['prepayment_handling', 'prepayment_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_prepayment_allocations(
    prepayment_i_d: UUID = Path(..., alias='PrepaymentID'),
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Allocations = ...,
):
    """
    Allows you to create an Allocation for prepayments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Prepayments/{PrepaymentID}/History',
    tags=['prepayment_handling', 'prepayment_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_prepayment_history(
    prepayment_i_d: UUID = Path(..., alias='PrepaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history record for a specific prepayment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Prepayments/{PrepaymentID}/History',
    tags=['prepayment_history_management', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_prepayment_history(
    prepayment_i_d: UUID = Path(..., alias='PrepaymentID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific prepayment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_orders(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    status: Optional[Status20] = Query(None, alias='Status'),
    date_from: Optional[str] = Query(None, alias='DateFrom'),
    date_to: Optional[str] = Query(None, alias='DateTo'),
    order: Optional[str] = None,
    page: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves purchase orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/PurchaseOrders',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_purchase_orders(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: PurchaseOrders = ...,
):
    """
    Updates or creates one or more purchase orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/PurchaseOrders',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_purchase_orders(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: PurchaseOrders = ...,
):
    """
    Creates one or more purchase orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderID}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific purchase order using a unique purchase order Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/PurchaseOrders/{PurchaseOrderID}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_purchase_order(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: PurchaseOrders = ...,
):
    """
    Updates a specific purchase order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderID}/Attachments',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order_attachments(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific purchase order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderID}/Attachments/{AttachmentID}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order_attachment_by_id(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves specific attachment for a specific purchase order using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order≠_attachment_by_file_name(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment for a specific purchase order by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_purchase_order_attachment_by_file_name(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates a specific attachment for a specific purchase order by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_purchase_order_attachment_by_file_name(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates attachment for a specific purchase order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderID}/History',
    tags=['purchase_order_handling', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order_history(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history for a specific purchase order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/PurchaseOrders/{PurchaseOrderID}/History',
    tags=['transaction_history_management', 'purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_purchase_order_history(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific purchase orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderID}/pdf',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order_as_pdf(
    purchase_order_i_d: UUID = Path(..., alias='PurchaseOrderID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves specific purchase order as PDF files using a unique purchase order Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/PurchaseOrders/{PurchaseOrderNumber}',
    tags=['purchase_order_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_purchase_order_by_number(
    purchase_order_number: str = Path(..., alias='PurchaseOrderNumber'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific purchase order using purchase order number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quotes(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    date_from: Optional[date] = Query(None, alias='DateFrom'),
    date_to: Optional[date] = Query(None, alias='DateTo'),
    expiry_date_from: Optional[date] = Query(None, alias='ExpiryDateFrom'),
    expiry_date_to: Optional[date] = Query(None, alias='ExpiryDateTo'),
    contact_i_d: Optional[UUID] = Query(None, alias='ContactID'),
    status: Optional[str] = Query(None, alias='Status'),
    page: Optional[int] = None,
    order: Optional[str] = None,
    quote_number: Optional[str] = Query(None, alias='QuoteNumber'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves sales quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Quotes',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_or_create_quotes(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Quotes = ...,
):
    """
    Updates or creates one or more quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Quotes',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_quotes(
    summarize_errors: Optional[bool] = Query(False, alias='summarizeErrors'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Quotes = ...,
):
    """
    Create one or more quotes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes/{QuoteID}',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quote(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific quote using a unique quote Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Quotes/{QuoteID}',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_quote(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Quotes = ...,
):
    """
    Updates a specific quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes/{QuoteID}/Attachments',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quote_attachments(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes/{QuoteID}/Attachments/{AttachmentID}',
    tags=['quote_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quote_attachment_by_id(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific quote using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes/{QuoteID}/Attachments/{FileName}',
    tags=['quote_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quote_attachment_by_file_name(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific quote by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Quotes/{QuoteID}/Attachments/{FileName}',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_quote_attachment_by_file_name(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates a specific attachment from a specific quote by filename
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Quotes/{QuoteID}/Attachments/{FileName}',
    tags=['quote_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_quote_attachment_by_file_name(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates attachment for a specific quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes/{QuoteID}/History',
    tags=['quote_operations', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quote_history(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history records of a specific quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Quotes/{QuoteID}/History',
    tags=['transaction_history_management', 'quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_quote_history(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific quote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Quotes/{QuoteID}/pdf',
    tags=['quote_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_quote_as_pdf(
    quote_i_d: UUID = Path(..., alias='QuoteID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific quote as a PDF file using a unique quote Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Receipts',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_receipts(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves draft expense claim receipts for any user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Receipts',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_receipt(
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Receipts = ...,
):
    """
    Creates draft expense claim receipts for any user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Receipts/{ReceiptID}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_receipt(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific draft expense claim receipt by using a unique receipt Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Receipts/{ReceiptID}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_receipt(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    unitdp: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: Receipts = ...,
):
    """
    Updates a specific draft expense claim receipts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Receipts/{ReceiptID}/Attachments',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_receipt_attachments(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments for a specific expense claim receipt
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Receipts/{ReceiptID}/Attachments/{AttachmentID}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_receipt_attachment_by_id(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachments from a specific expense claim receipts by using a unique attachment Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Receipts/{ReceiptID}/Attachments/{FileName}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_receipt_attachment_by_file_name(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific expense claim receipts by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Receipts/{ReceiptID}/Attachments/{FileName}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_receipt_attachment_by_file_name(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates a specific attachment on a specific expense claim receipts by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Receipts/{ReceiptID}/Attachments/{FileName}',
    tags=['expense_claim_handling', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_receipt_attachment_by_file_name(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates an attachment on a specific expense claim receipts by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Receipts/{ReceiptID}/History',
    tags=['transaction_history_management', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_receipt_history(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a history record for a specific receipt
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/Receipts/{ReceiptID}/History',
    tags=['transaction_history_management', 'receipt_processing'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_receipt_history(
    receipt_i_d: UUID = Path(..., alias='ReceiptID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a history record for a specific receipt
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/RepeatingInvoices',
    tags=['invoice_operations', 'invoice_history_records'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_repeating_invoices(
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves repeating invoices
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/RepeatingInvoices/{RepeatingInvoiceID}',
    tags=['invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_repeating_invoice(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific repeating invoice by using a unique repeating invoice Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments',
    tags=['invoice_attachment_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_repeating_invoice_attachments(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves attachments from a specific repeating invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}',
    tags=['invoice_attachment_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_repeating_invoice_attachment_by_id(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    attachment_i_d: UUID = Path(..., alias='AttachmentID'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific repeating invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}',
    tags=['invoice_operations', 'invoice_attachment_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_repeating_invoice_attachment_by_file_name(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    file_name: str = Path(..., alias='FileName'),
    content_type: str = Header(..., alias='contentType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific attachment from a specific repeating invoices by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}',
    tags=['invoice_attachment_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_repeating_invoice_attachment_by_file_name(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Updates a specific attachment from a specific repeating invoices by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}',
    tags=['invoice_attachment_operations', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_repeating_invoice_attachment_by_file_name(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    file_name: str = Path(..., alias='FileName'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    request: Request = ...,
):
    """
    Creates an attachment from a specific repeating invoices by file name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/RepeatingInvoices/{RepeatingInvoiceID}/History',
    tags=['invoice_history_records', 'invoice_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_repeating_invoice_history(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves history record for a specific repeating invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/RepeatingInvoices/{RepeatingInvoiceID}/History',
    tags=[
        'invoice_history_records',
        'transaction_history_management',
        'invoice_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_repeating_invoice_history(
    repeating_invoice_i_d: UUID = Path(..., alias='RepeatingInvoiceID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: HistoryRecords = ...,
):
    """
    Creates a  history record for a specific repeating invoice
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports',
    tags=['financial_report_generation', 'organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_b_a_sor_g_s_t_list(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id')
):
    """
    Retrieves report for BAS (only valid for AU orgs)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/AgedPayablesByContact',
    tags=['financial_report_generation', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_aged_payables_by_contact(
    contact_id: UUID = Query(..., alias='contactId'),
    date: Optional[date] = None,
    from_date: Optional[date] = Query(None, alias='fromDate'),
    to_date: Optional[date] = Query(None, alias='toDate'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for aged payables by contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/AgedReceivablesByContact',
    tags=['financial_report_generation', 'individual_contact_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_aged_receivables_by_contact(
    contact_id: UUID = Query(..., alias='contactId'),
    date: Optional[date] = None,
    from_date: Optional[date] = Query(None, alias='fromDate'),
    to_date: Optional[date] = Query(None, alias='toDate'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for aged receivables by contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/BalanceSheet',
    tags=['financial_report_generation'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_balance_sheet(
    date: Optional[date] = None,
    periods: Optional[int] = None,
    timeframe: Optional[Timeframe] = None,
    tracking_option_i_d1: Optional[str] = Query(None, alias='trackingOptionID1'),
    tracking_option_i_d2: Optional[str] = Query(None, alias='trackingOptionID2'),
    standard_layout: Optional[bool] = Query(None, alias='standardLayout'),
    payments_only: Optional[bool] = Query(None, alias='paymentsOnly'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for balancesheet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/BankSummary',
    tags=['financial_report_generation', 'transaction_history_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_bank_summary(
    from_date: Optional[date] = Query(None, alias='fromDate'),
    to_date: Optional[date] = Query(None, alias='toDate'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for bank summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/BudgetSummary',
    tags=['financial_report_generation', 'organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_budget_summary(
    date: Optional[date] = None,
    period: Optional[int] = None,
    timeframe: Optional[int] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for budget summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/ExecutiveSummary',
    tags=['financial_report_generation'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_executive_summary(
    date: Optional[date] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for executive summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/ProfitAndLoss',
    tags=['financial_report_generation'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_profit_and_loss(
    from_date: Optional[date] = Query(None, alias='fromDate'),
    to_date: Optional[date] = Query(None, alias='toDate'),
    periods: Optional[int] = None,
    timeframe: Optional[Timeframe] = None,
    tracking_category_i_d: Optional[str] = Query(None, alias='trackingCategoryID'),
    tracking_category_i_d2: Optional[str] = Query(None, alias='trackingCategoryID2'),
    tracking_option_i_d: Optional[str] = Query(None, alias='trackingOptionID'),
    tracking_option_i_d2: Optional[str] = Query(None, alias='trackingOptionID2'),
    standard_layout: Optional[bool] = Query(None, alias='standardLayout'),
    payments_only: Optional[bool] = Query(None, alias='paymentsOnly'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for profit and loss
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/TenNinetyNine',
    tags=['financial_report_generation'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_ten_ninety_nine(
    report_year: Optional[str] = Query(None, alias='reportYear'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieve reports for 1099
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/TrialBalance',
    tags=['financial_report_generation', 'account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_trial_balance(
    date: Optional[date] = None,
    payments_only: Optional[bool] = Query(None, alias='paymentsOnly'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves report for trial balance
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Reports/{ReportID}',
    tags=['financial_report_generation', 'organisation_information_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_report_b_a_sor_g_s_t(
    report_i_d: str = Path(..., alias='ReportID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific report for BAS using a unique report Id (only valid for AU orgs)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/Setup',
    tags=['account_setup_process', 'account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def post_setup(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: Setup = ...
):
    """
    Sets the chart of accounts, the conversion date and conversion balances
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/TaxRates',
    tags=['tax_rate_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tax_rates(
    where: Optional[str] = None,
    order: Optional[str] = None,
    tax_type: Optional[str] = Query(None, alias='TaxType'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves tax rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/TaxRates',
    tags=['tax_rate_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_tax_rate(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: TaxRates = ...
):
    """
    Updates tax rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/TaxRates',
    tags=['tax_rate_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tax_rates(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'), body: TaxRates = ...
):
    """
    Creates one or more tax rates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/TrackingCategories',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tracking_categories(
    where: Optional[str] = None,
    order: Optional[str] = None,
    include_archived: Optional[bool] = Query(None, alias='includeArchived'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves tracking categories and options
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/TrackingCategories',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tracking_category(
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: TrackingCategory = ...,
):
    """
    Create tracking categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/TrackingCategories/{TrackingCategoryID}',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_tracking_category(
    tracking_category_i_d: UUID = Path(..., alias='TrackingCategoryID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes a specific tracking category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/TrackingCategories/{TrackingCategoryID}',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_tracking_category(
    tracking_category_i_d: UUID = Path(..., alias='TrackingCategoryID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves specific tracking categories and options using a unique tracking category Id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/TrackingCategories/{TrackingCategoryID}',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_tracking_category(
    tracking_category_i_d: UUID = Path(..., alias='TrackingCategoryID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: TrackingCategory = ...,
):
    """
    Updates a specific tracking category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/TrackingCategories/{TrackingCategoryID}/Options',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def create_tracking_options(
    tracking_category_i_d: UUID = Path(..., alias='TrackingCategoryID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: TrackingOption = ...,
):
    """
    Creates options for a specific tracking category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def delete_tracking_options(
    tracking_category_i_d: UUID = Path(..., alias='TrackingCategoryID'),
    tracking_option_i_d: UUID = Path(..., alias='TrackingOptionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Deletes a specific option for a specific tracking category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}',
    tags=['tracking_category_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def update_tracking_options(
    tracking_category_i_d: UUID = Path(..., alias='TrackingCategoryID'),
    tracking_option_i_d: UUID = Path(..., alias='TrackingOptionID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
    body: TrackingOption = ...,
):
    """
    Updates a specific option for a specific tracking category
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Users',
    tags=['user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_users(
    if__modified__since: Optional[datetime] = Header(None, alias='If-Modified-Since'),
    where: Optional[str] = None,
    order: Optional[str] = None,
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/Users/{UserID}',
    tags=['user_account_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
    ],
)
def get_user(
    user_i_d: UUID = Path(..., alias='UserID'),
    xero_tenant_id: str = Header(..., alias='xero-tenant-id'),
):
    """
    Retrieves a specific user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
